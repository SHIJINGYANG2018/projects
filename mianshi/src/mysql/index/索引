InnoDB数据页结构
        学习来自
                https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483678&idx=1&sn=913780d42e7a81fd3f9b747da4fba8ec&chksm=979688eca0e101fa0913c3d2e6107dfa3a6c151a075c8d68ab3f44c7c364d9510f9e1179d94d&scene=21#wechat_redirect

                                InnoDB数据页结构示意图（7部分）  如图：/image/innoDB页结构示意图.webp
                名称	            中文名	                占用空间大小	    简单描述

            File Header	        文件头	                38字节	        一些描述页的信息
            Page Header	        页头	                    56字节	        页的状态信息
            Infimum + Supremum	最小记录和最大记录	    26字节	        两个虚拟的行记录
            User Records	    用户记录	                不确定	        实际存储的行记录内容
            Free Space	        空闲空间	                不确定	        页中尚未使用的空间
            Page Directory	    页目录	                不确定	        页中的记录相对位置
            File Trailer	    文件结尾	                8字节	        校验页是否完整
          记录在页中的存储
            在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。
            但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，
            都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，
            当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，
            如果还有新的记录插入的话，就需要去申请新的页了。

            记录头信息属性
                名称	            大小（单位：bit）	描述
                预留位1  	    1	            没有使用
                预留位2	         1	            没有使用
                delete_mask 	1	            标记该记录是否被删除
                min_rec_mask	1	            标记该记录是否为B+树的非叶子节点中的最小记录
                n_owned	        4	            表示当前槽管理的记录数
                heap_no	        13	            表示当前记录在记录堆的位置信息
                record_type	    3	            表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录
                next_record	    16	            表示下一条记录的相对位置

             提示

             这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，
             所以只是打个删除标记而已，而且这部分存储空间之后还可以重用，也就是说之后如果有新记录插入到表中的话，
             可能把这些被删除的记录占用的存储空间覆盖掉
             如果你想彻底的从磁盘上移除这些被删除的记录，可以使用这个语句： `optimize table 表名;`
             执行这个命令后服务器会重新规划表中记录的存储方式，把被标记为删除的记录从磁盘上移除。
    总结
   1、 InnoDB为了不同的目的而设计了不同类型的页，用于存放我么记录的页也叫做数据页。

   2、 一个数据页可以被分为7个部分，分别是

        File Header，表示文件头，占固定的38字节。

        Page Header，表示页里的一些状态信息，占固定的56个字节。

        Infimum + Supremum，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节。

        User Records：真实存储我们插入的记录的部分，大小不固定。

        Free Space：页中尚未使用的部分，大小不确定。

        Page Directory：页中的记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。

        File Trailer：用于检验页是否完整的部分，占用固定的8个字节。

    3、每个记录的头信息中都有一个next_record属性，从而使页中的所有记录串联成一个单链表。

    4、InnoDB会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory中，所以在一个
        页中根据主键查找记录是非常快的，分为两步：

            通过二分法确定该记录所在的槽。

            通过记录的next_record属性组成的链表遍历查找该槽中的各个记录。

    5、每个数据页的File Header部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表。

    6、为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和LSN值，如果首部和尾部的校验和和LSN值校验
        不成功的话，就说明同步过程出现了问题。

InnoDB记录存储结构
        转自
        https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483670&idx=1&sn=751d84d0ce50d64934d636014abe2023&chksm=979688e4a0e101f2a51d1f06ec75e25c56f8936321ae43badc2fe9fc1257b4dc1c24223699de&scene=21#wechat_redirect

        特点
        页是MySQL中磁盘和内存交互的基本单位，也是MySQL是管理存储空间的基本单位。

        指定和修改行格式的语法如下：

        CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
        ALTER TABLE 表名 ROW_FORMAT=行格式名称
        InnoDB目前定义了4中行格式

        COMPACT行格式

        具体组成如图：

        image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB
        image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB
        Redundant行格式

        具体组成如图：

        这两种行格式类似于COMPACT行格式，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

        另外，Compressed行格式会把存储在其他页面中的数据压缩处理。

        一个页一般是16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为行溢出。

        对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

索引提高检索速度
        没有用索引我们是需要遍历双向链表来定位对应的页，现在通过**“目录”**就可以很快地定位到对应的页上了！
        其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。
索引降低增删改的速度
        B+树是平衡树的一种。
        平衡树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

聚集和非聚集索引
        聚集索引就是以主键创建的索引
        非聚集索引就是以非主键创建的索引

        区别
        聚集索引在叶子节点存储的是表中的数据
        非聚集索引在叶子节点存储的是主键和索引列
        使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。(拿到主键再查找这个过程叫做回表)
索引最左匹配原则
        索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即联合索引。
        如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询(>、<、between、like左匹配)
            等就不能进一步匹配了，后续退化为线性查找。
        因此，列的排列顺序决定了可命中索引的列数。

        例如
            如有索引(a, b, c, d)，查询条件a = 1 and b = 2 and c > 3 and d = 4，
            则会在每个节点依次命中a、b、c，无法命中d。
            (很简单：索引命中只能是相等的情况，不能是范围匹配)

=、in自动优化顺序
        如有索引(a, b, c, d)，查询条件c > 3 and b = 2 and a = 1 and d < 4与a = 1 and c > 3 and b = 2 and d < 4等顺序都
        是可以的，MySQL会自动优化为a = 1 and b = 2 and c > 3 and d < 4，依次命中a、b、c。


索引总结
        1、最左前缀匹配原则      MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配。
        2、尽量选择区分度高的列作为索引
            区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。
            表示字段不重复的比率，比率越大我们扫描的记录数就越少。
        3、索引列不能参与计算，尽量保持列“干净”
            比如，FROM_UNIXTIME(create_time) = '2016-06-06' 就不能使用索引，
            原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，
            需要把所有元素都应用函数才能比较，显然这样的代价太大。
            所以语句要写成 ： create_time = UNIX_TIMESTAMP('2016-06-06')
        4、尽可能的扩展索引
            尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
        5、单个多列组合索引和多个单列索引的检索查询效果不同，
            因为在执行SQL时，MySQL只能使用一个索引，
            会从多个单列索引中选择一个限制最为严格的索引。
